{"ast":null,"code":"'use strict'; // Load modules\n\nconst Hoek = require('hoek');\n\nconst Settings = require('./settings');\n\nconst Ref = require('../../ref');\n\nconst Errors = require('../../errors');\n\nconst State = require('../state');\n\nconst Symbols = require('../symbols'); // Delay-loaded to prevent circular dependencies\n\n\nlet Alternatives = null;\nlet Cast = null;\nlet Schemas = null; // Declare internals\n\nconst internals = {\n  Set: require('../../set')\n};\ninternals.defaults = {\n  abortEarly: true,\n  convert: true,\n  allowUnknown: false,\n  skipFunctions: false,\n  stripUnknown: false,\n  language: {},\n  presence: 'optional',\n  strip: false,\n  noDefaults: false,\n  escapeHtml: false // context: null\n\n};\nmodule.exports = internals.Any = class {\n  constructor() {\n    Cast = Cast || require('../../cast');\n    this.isJoi = true;\n    this._type = 'any';\n    this._settings = null;\n    this._valids = new internals.Set();\n    this._invalids = new internals.Set();\n    this._tests = [];\n    this._refs = [];\n    this._flags = {\n      /*\r\n       presence: 'optional',                   // optional, required, forbidden, ignore\r\n       allowOnly: false,\r\n       allowUnknown: undefined,\r\n       default: undefined,\r\n       forbidden: false,\r\n       encoding: undefined,\r\n       insensitive: false,\r\n       trim: false,\r\n       normalize: undefined,                   // NFC, NFD, NFKC, NFKD\r\n       case: undefined,                        // upper, lower\r\n       empty: undefined,\r\n       func: false,\r\n       raw: false\r\n       */\n    };\n    this._description = null;\n    this._unit = null;\n    this._notes = [];\n    this._tags = [];\n    this._examples = [];\n    this._meta = [];\n    this._inner = {}; // Hash of arrays of immutable objects\n  }\n\n  _init() {\n    return this;\n  }\n\n  get schemaType() {\n    return this._type;\n  }\n\n  createError(type, context, state, options, flags = this._flags) {\n    return Errors.create(type, context, state, options, flags);\n  }\n\n  createOverrideError(type, context, state, options, message, template) {\n    return Errors.create(type, context, state, options, this._flags, message, template);\n  }\n\n  checkOptions(options) {\n    Schemas = Schemas || require('../../schemas');\n    const result = Schemas.options.validate(options);\n\n    if (result.error) {\n      throw new Error(result.error.details[0].message);\n    }\n  }\n\n  clone() {\n    const obj = Object.create(Object.getPrototypeOf(this));\n    obj.isJoi = true;\n    obj._currentJoi = this._currentJoi;\n    obj._type = this._type;\n    obj._settings = this._settings;\n    obj._baseType = this._baseType;\n    obj._valids = this._valids.slice();\n    obj._invalids = this._invalids.slice();\n    obj._tests = this._tests.slice();\n    obj._refs = this._refs.slice();\n    obj._flags = Hoek.clone(this._flags);\n    obj._description = this._description;\n    obj._unit = this._unit;\n    obj._notes = this._notes.slice();\n    obj._tags = this._tags.slice();\n    obj._examples = this._examples.slice();\n    obj._meta = this._meta.slice();\n    obj._inner = {};\n    const inners = Object.keys(this._inner);\n\n    for (let i = 0; i < inners.length; ++i) {\n      const key = inners[i];\n      obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\n    }\n\n    return obj;\n  }\n\n  concat(schema) {\n    Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\n    Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\n    let obj = this.clone();\n\n    if (this._type === 'any' && schema._type !== 'any') {\n      // Reset values as if we were \"this\"\n      const tmpObj = schema.clone();\n      const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit', '_notes', '_tags', '_examples', '_meta', '_inner'];\n\n      for (let i = 0; i < keysToRestore.length; ++i) {\n        tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\n      }\n\n      obj = tmpObj;\n    }\n\n    obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\n\n    obj._valids.merge(schema._valids, schema._invalids);\n\n    obj._invalids.merge(schema._invalids, schema._valids);\n\n    obj._tests.push(...schema._tests);\n\n    obj._refs.push(...schema._refs);\n\n    if (obj._flags.empty && schema._flags.empty) {\n      obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\n      const flags = Object.assign({}, schema._flags);\n      delete flags.empty;\n      Hoek.merge(obj._flags, flags);\n    } else if (schema._flags.empty) {\n      obj._flags.empty = schema._flags.empty;\n      const flags = Object.assign({}, schema._flags);\n      delete flags.empty;\n      Hoek.merge(obj._flags, flags);\n    } else {\n      Hoek.merge(obj._flags, schema._flags);\n    }\n\n    obj._description = schema._description || obj._description;\n    obj._unit = schema._unit || obj._unit;\n\n    obj._notes.push(...schema._notes);\n\n    obj._tags.push(...schema._tags);\n\n    obj._examples.push(...schema._examples);\n\n    obj._meta.push(...schema._meta);\n\n    const inners = Object.keys(schema._inner);\n    const isObject = obj._type === 'object';\n\n    for (let i = 0; i < inners.length; ++i) {\n      const key = inners[i];\n      const source = schema._inner[key];\n\n      if (source) {\n        const target = obj._inner[key];\n\n        if (target) {\n          if (isObject && key === 'children') {\n            const keys = {};\n\n            for (let j = 0; j < target.length; ++j) {\n              keys[target[j].key] = j;\n            }\n\n            for (let j = 0; j < source.length; ++j) {\n              const sourceKey = source[j].key;\n\n              if (keys[sourceKey] >= 0) {\n                target[keys[sourceKey]] = {\n                  key: sourceKey,\n                  schema: target[keys[sourceKey]].schema.concat(source[j].schema)\n                };\n              } else {\n                target.push(source[j]);\n              }\n            }\n          } else {\n            obj._inner[key] = obj._inner[key].concat(source);\n          }\n        } else {\n          obj._inner[key] = source.slice();\n        }\n      }\n    }\n\n    return obj;\n  }\n\n  _test(name, arg, func, options) {\n    const obj = this.clone();\n\n    obj._tests.push({\n      func,\n      name,\n      arg,\n      options\n    });\n\n    return obj;\n  }\n\n  _testUnique(name, arg, func, options) {\n    const obj = this.clone();\n    obj._tests = obj._tests.filter(test => test.name !== name);\n\n    obj._tests.push({\n      func,\n      name,\n      arg,\n      options\n    });\n\n    return obj;\n  }\n\n  options(options) {\n    Hoek.assert(!options.context, 'Cannot override context');\n    this.checkOptions(options);\n    const obj = this.clone();\n    obj._settings = Settings.concat(obj._settings, options);\n    return obj;\n  }\n\n  strict(isStrict) {\n    const obj = this.clone();\n    const convert = isStrict === undefined ? false : !isStrict;\n    obj._settings = Settings.concat(obj._settings, {\n      convert\n    });\n    return obj;\n  }\n\n  raw(isRaw) {\n    const value = isRaw === undefined ? true : isRaw;\n\n    if (this._flags.raw === value) {\n      return this;\n    }\n\n    const obj = this.clone();\n    obj._flags.raw = value;\n    return obj;\n  }\n\n  error(err, options = {\n    self: false\n  }) {\n    Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\n    const unknownKeys = Object.keys(options).filter(k => !['self'].includes(k));\n    Hoek.assert(unknownKeys.length === 0, `Options ${unknownKeys} are unknown`);\n    const obj = this.clone();\n    obj._flags.error = err;\n\n    if (options.self) {\n      obj._flags.selfError = true;\n    }\n\n    return obj;\n  }\n\n  allow(...values) {\n    const obj = this.clone();\n    values = Hoek.flatten(values);\n\n    for (let i = 0; i < values.length; ++i) {\n      const value = values[i];\n      Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n\n      obj._invalids.remove(value);\n\n      obj._valids.add(value, obj._refs);\n    }\n\n    return obj;\n  }\n\n  valid(...values) {\n    const obj = this.allow(...values);\n    obj._flags.allowOnly = true;\n    return obj;\n  }\n\n  invalid(...values) {\n    const obj = this.clone();\n    values = Hoek.flatten(values);\n\n    for (let i = 0; i < values.length; ++i) {\n      const value = values[i];\n      Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n\n      obj._valids.remove(value);\n\n      obj._invalids.add(value, obj._refs);\n    }\n\n    return obj;\n  }\n\n  required() {\n    if (this._flags.presence === 'required') {\n      return this;\n    }\n\n    const obj = this.clone();\n    obj._flags.presence = 'required';\n    return obj;\n  }\n\n  optional() {\n    if (this._flags.presence === 'optional') {\n      return this;\n    }\n\n    const obj = this.clone();\n    obj._flags.presence = 'optional';\n    return obj;\n  }\n\n  forbidden() {\n    if (this._flags.presence === 'forbidden') {\n      return this;\n    }\n\n    const obj = this.clone();\n    obj._flags.presence = 'forbidden';\n    return obj;\n  }\n\n  strip() {\n    if (this._flags.strip) {\n      return this;\n    }\n\n    const obj = this.clone();\n    obj._flags.strip = true;\n    return obj;\n  }\n\n  applyFunctionToChildren(children, fn, args = [], root) {\n    children = [].concat(children);\n\n    if (children.length !== 1 || children[0] !== '') {\n      root = root ? root + '.' : '';\n      const extraChildren = (children[0] === '' ? children.slice(1) : children).map(child => {\n        return root + child;\n      });\n      throw new Error('unknown key(s) ' + extraChildren.join(', '));\n    }\n\n    return this[fn](...args);\n  }\n\n  default(value, description) {\n    if (typeof value === 'function' && !Ref.isRef(value)) {\n      if (!value.description && description) {\n        value.description = description;\n      }\n\n      if (!this._flags.func) {\n        Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\n      }\n    }\n\n    const obj = this.clone();\n    obj._flags.default = value;\n    Ref.push(obj._refs, value);\n    return obj;\n  }\n\n  empty(schema) {\n    const obj = this.clone();\n\n    if (schema === undefined) {\n      delete obj._flags.empty;\n    } else {\n      obj._flags.empty = Cast.schema(this._currentJoi, schema);\n    }\n\n    return obj;\n  }\n\n  when(condition, options) {\n    Hoek.assert(options && typeof options === 'object', 'Invalid options');\n    Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \"then\" or \"otherwise\"');\n    const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\n    const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\n    Alternatives = Alternatives || require('../alternatives');\n    const alternativeOptions = {\n      then,\n      otherwise\n    };\n\n    if (Object.prototype.hasOwnProperty.call(options, 'is')) {\n      alternativeOptions.is = options.is;\n    }\n\n    const obj = Alternatives.when(condition, alternativeOptions);\n    obj._flags.presence = 'ignore';\n    obj._baseType = this;\n    return obj;\n  }\n\n  description(desc) {\n    Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\n    const obj = this.clone();\n    obj._description = desc;\n    return obj;\n  }\n\n  notes(notes) {\n    Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\n    const obj = this.clone();\n    obj._notes = obj._notes.concat(notes);\n    return obj;\n  }\n\n  tags(tags) {\n    Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\n    const obj = this.clone();\n    obj._tags = obj._tags.concat(tags);\n    return obj;\n  }\n\n  meta(meta) {\n    Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\n    const obj = this.clone();\n    obj._meta = obj._meta.concat(meta);\n    return obj;\n  }\n\n  example(...examples) {\n    Hoek.assert(examples.length > 0, 'Missing examples');\n    const processed = [];\n\n    for (let i = 0; i < examples.length; ++i) {\n      const example = [].concat(examples[i]);\n      Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\n      const value = example[0];\n      let options = example[1];\n\n      if (options !== undefined) {\n        Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\n        const unknownOptions = Object.keys(options).filter(option => !['parent', 'context'].includes(option));\n        Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\n      } else {\n        options = {};\n      }\n\n      const localState = new State('', [], options.parent || null);\n\n      const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? {\n        context: options.context\n      } : null));\n\n      Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\n      const ex = {\n        value\n      };\n\n      if (Object.keys(options).length) {\n        ex.options = options;\n      }\n\n      processed.push(ex);\n    }\n\n    const obj = this.clone();\n    obj._examples = processed;\n    return obj;\n  }\n\n  unit(name) {\n    Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\n    const obj = this.clone();\n    obj._unit = name;\n    return obj;\n  }\n\n  _prepareEmptyValue(value) {\n    if (typeof value === 'string' && this._flags.trim) {\n      return value.trim();\n    }\n\n    return value;\n  }\n\n  _validate(value, state, options, reference) {\n    const originalValue = value; // Setup state and settings\n\n    state = state || new State('', [], null, reference);\n\n    if (this._settings) {\n      const isDefaultOptions = options === internals.defaults;\n\n      if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\n        options = this._settings[Symbols.settingsCache];\n      } else {\n        options = Settings.concat(options, this._settings);\n\n        if (isDefaultOptions) {\n          this._settings[Symbols.settingsCache] = options;\n        }\n      }\n    }\n\n    let errors = [];\n\n    if (this._coerce) {\n      const coerced = this._coerce(value, state, options);\n\n      if (coerced.errors) {\n        value = coerced.value;\n        errors = errors.concat(coerced.errors);\n        return this._finalizeValue(value, originalValue, errors, state, options); // Coerced error always aborts early\n      }\n\n      value = coerced.value;\n    }\n\n    if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\n      value = undefined;\n    } // Check presence requirements\n\n\n    const presence = this._flags.presence || options.presence;\n\n    if (presence === 'optional') {\n      if (value === undefined) {\n        const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\n\n        if (isDeepDefault && this._type === 'object') {\n          value = {};\n        } else {\n          return this._finalizeValue(value, originalValue, errors, state, options);\n        }\n      }\n    } else if (presence === 'required' && value === undefined) {\n      errors.push(this.createError('any.required', null, state, options));\n      return this._finalizeValue(value, originalValue, errors, state, options);\n    } else if (presence === 'forbidden') {\n      if (value === undefined) {\n        return this._finalizeValue(value, originalValue, errors, state, options);\n      }\n\n      errors.push(this.createError('any.unknown', null, state, options));\n      return this._finalizeValue(value, originalValue, errors, state, options);\n    } // Check allowed and denied values using the original value\n\n\n    let match = this._valids.get(value, state, options, this._flags.insensitive);\n\n    if (match) {\n      if (options.convert) {\n        value = match.value;\n      }\n\n      return this._finalizeValue(value, originalValue, errors, state, options);\n    }\n\n    if (this._invalids.has(value, state, options, this._flags.insensitive)) {\n      errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', {\n        value,\n        invalids: this._invalids.values({\n          stripUndefined: true\n        })\n      }, state, options));\n\n      if (options.abortEarly) {\n        return this._finalizeValue(value, originalValue, errors, state, options);\n      }\n    } // Convert value and validate type\n\n\n    if (this._base) {\n      const base = this._base(value, state, options);\n\n      if (base.errors) {\n        value = base.value;\n        errors = errors.concat(base.errors);\n        return this._finalizeValue(value, originalValue, errors, state, options); // Base error always aborts early\n      }\n\n      if (base.value !== value) {\n        value = base.value; // Check allowed and denied values using the converted value\n\n        match = this._valids.get(value, state, options, this._flags.insensitive);\n\n        if (match) {\n          value = match.value;\n          return this._finalizeValue(value, originalValue, errors, state, options);\n        }\n\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\n          errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', {\n            value,\n            invalids: this._invalids.values({\n              stripUndefined: true\n            })\n          }, state, options));\n\n          if (options.abortEarly) {\n            return this._finalizeValue(value, originalValue, errors, state, options);\n          }\n        }\n      }\n    } // Required values did not match\n\n\n    if (this._flags.allowOnly) {\n      errors.push(this.createError('any.allowOnly', {\n        value,\n        valids: this._valids.values({\n          stripUndefined: true\n        })\n      }, state, options));\n\n      if (options.abortEarly) {\n        return this._finalizeValue(value, originalValue, errors, state, options);\n      }\n    } // Validate tests\n\n\n    for (let i = 0; i < this._tests.length; ++i) {\n      const test = this._tests[i];\n      const ret = test.func.call(this, value, state, options);\n\n      if (ret instanceof Errors.Err) {\n        errors.push(ret);\n\n        if (options.abortEarly) {\n          return this._finalizeValue(value, originalValue, errors, state, options);\n        }\n      } else {\n        value = ret;\n      }\n    }\n\n    return this._finalizeValue(value, originalValue, errors, state, options);\n  }\n\n  _finalizeValue(value, originalValue, errors, state, options) {\n    let finalValue;\n\n    if (value !== undefined) {\n      finalValue = this._flags.raw ? originalValue : value;\n    } else if (options.noDefaults) {\n      finalValue = value;\n    } else if (Ref.isRef(this._flags.default)) {\n      finalValue = this._flags.default(state.parent, options);\n    } else if (typeof this._flags.default === 'function' && !(this._flags.func && !this._flags.default.description)) {\n      let args;\n\n      if (state.parent !== null && this._flags.default.length > 0) {\n        args = [Hoek.clone(state.parent), options];\n      }\n\n      const defaultValue = internals._try(this._flags.default, args);\n\n      finalValue = defaultValue.value;\n\n      if (defaultValue.error) {\n        errors.push(this.createError('any.default', {\n          error: defaultValue.error\n        }, state, options));\n      }\n    } else {\n      finalValue = Hoek.clone(this._flags.default);\n    }\n\n    if (errors.length && typeof this._flags.error === 'function' && (!this._flags.selfError || errors.some(e => state.path.length === e.path.length))) {\n      const change = this._flags.error.call(this, errors);\n\n      if (typeof change === 'string') {\n        errors = [this.createOverrideError('override', {\n          reason: errors\n        }, state, options, change)];\n      } else {\n        errors = [].concat(change).map(err => {\n          return err instanceof Error ? err : this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\n        });\n      }\n    }\n\n    return {\n      value: this._flags.strip ? undefined : finalValue,\n      finalValue,\n      errors: errors.length ? errors : null\n    };\n  }\n\n  _validateWithOptions(value, options, callback) {\n    if (options) {\n      this.checkOptions(options);\n    }\n\n    const settings = Settings.concat(internals.defaults, options);\n\n    const result = this._validate(value, null, settings);\n\n    const errors = Errors.process(result.errors, value);\n\n    if (callback) {\n      return callback(errors, result.value);\n    }\n\n    return {\n      error: errors,\n      value: result.value,\n\n      then(resolve, reject) {\n        if (errors) {\n          return Promise.reject(errors).catch(reject);\n        }\n\n        return Promise.resolve(result.value).then(resolve);\n      },\n\n      catch(reject) {\n        if (errors) {\n          return Promise.reject(errors).catch(reject);\n        }\n\n        return Promise.resolve(result.value);\n      }\n\n    };\n  }\n\n  validate(value, options, callback) {\n    if (typeof options === 'function') {\n      return this._validateWithOptions(value, null, options);\n    }\n\n    return this._validateWithOptions(value, options, callback);\n  }\n\n  describe() {\n    const description = {\n      type: this._type\n    };\n    const flags = Object.keys(this._flags);\n\n    if (flags.length) {\n      if (['empty', 'default', 'lazy', 'label'].some(flag => this._flags.hasOwnProperty(flag))) {\n        description.flags = {};\n\n        for (let i = 0; i < flags.length; ++i) {\n          const flag = flags[i];\n\n          if (flag === 'empty') {\n            description.flags[flag] = this._flags[flag].describe();\n          } else if (flag === 'default') {\n            if (Ref.isRef(this._flags[flag])) {\n              description.flags[flag] = this._flags[flag].toString();\n            } else if (typeof this._flags[flag] === 'function') {\n              description.flags[flag] = {\n                description: this._flags[flag].description,\n                function: this._flags[flag]\n              };\n            } else {\n              description.flags[flag] = this._flags[flag];\n            }\n          } else if (flag === 'lazy' || flag === 'label') {// We don't want it in the description\n          } else {\n            description.flags[flag] = this._flags[flag];\n          }\n        }\n      } else {\n        description.flags = this._flags;\n      }\n    }\n\n    if (this._settings) {\n      description.options = Hoek.clone(this._settings);\n    }\n\n    if (this._baseType) {\n      description.base = this._baseType.describe();\n    }\n\n    if (this._description) {\n      description.description = this._description;\n    }\n\n    if (this._notes.length) {\n      description.notes = this._notes;\n    }\n\n    if (this._tags.length) {\n      description.tags = this._tags;\n    }\n\n    if (this._meta.length) {\n      description.meta = this._meta;\n    }\n\n    if (this._examples.length) {\n      description.examples = this._examples;\n    }\n\n    if (this._unit) {\n      description.unit = this._unit;\n    }\n\n    const valids = this._valids.values();\n\n    if (valids.length) {\n      description.valids = valids.map(v => {\n        return Ref.isRef(v) ? v.toString() : v;\n      });\n    }\n\n    const invalids = this._invalids.values();\n\n    if (invalids.length) {\n      description.invalids = invalids.map(v => {\n        return Ref.isRef(v) ? v.toString() : v;\n      });\n    }\n\n    description.rules = [];\n\n    for (let i = 0; i < this._tests.length; ++i) {\n      const validator = this._tests[i];\n      const item = {\n        name: validator.name\n      };\n\n      if (validator.arg !== void 0) {\n        item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\n      }\n\n      const options = validator.options;\n\n      if (options) {\n        if (options.hasRef) {\n          item.arg = {};\n          const keys = Object.keys(validator.arg);\n\n          for (let j = 0; j < keys.length; ++j) {\n            const key = keys[j];\n            const value = validator.arg[key];\n            item.arg[key] = Ref.isRef(value) ? value.toString() : value;\n          }\n        }\n\n        if (typeof options.description === 'string') {\n          item.description = options.description;\n        } else if (typeof options.description === 'function') {\n          item.description = options.description(item.arg);\n        }\n      }\n\n      description.rules.push(item);\n    }\n\n    if (!description.rules.length) {\n      delete description.rules;\n    }\n\n    const label = this._getLabel();\n\n    if (label) {\n      description.label = label;\n    }\n\n    return description;\n  }\n\n  label(name) {\n    Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\n    const obj = this.clone();\n    obj._flags.label = name;\n    return obj;\n  }\n\n  _getLabel(def) {\n    return this._flags.label || def;\n  }\n\n};\ninternals.Any.prototype.isImmutable = true; // Prevents Hoek from deep cloning schema objects\n// Aliases\n\ninternals.Any.prototype.only = internals.Any.prototype.equal = internals.Any.prototype.valid;\ninternals.Any.prototype.disallow = internals.Any.prototype.not = internals.Any.prototype.invalid;\ninternals.Any.prototype.exist = internals.Any.prototype.required;\n\ninternals._try = function (fn, args = []) {\n  let err;\n  let result;\n\n  try {\n    result = fn(...args);\n  } catch (e) {\n    err = e;\n  }\n\n  return {\n    value: result,\n    error: err\n  };\n};","map":{"version":3,"sources":["C:/Users/usuario/desktop/chained/chained/node_modules/joi/lib/types/any/index.js"],"names":["Hoek","require","Settings","Ref","Errors","State","Symbols","Alternatives","Cast","Schemas","internals","Set","defaults","abortEarly","convert","allowUnknown","skipFunctions","stripUnknown","language","presence","strip","noDefaults","escapeHtml","module","exports","Any","constructor","isJoi","_type","_settings","_valids","_invalids","_tests","_refs","_flags","_description","_unit","_notes","_tags","_examples","_meta","_inner","_init","schemaType","createError","type","context","state","options","flags","create","createOverrideError","message","template","checkOptions","result","validate","error","Error","details","clone","obj","Object","getPrototypeOf","_currentJoi","_baseType","slice","inners","keys","i","length","key","concat","schema","assert","tmpObj","keysToRestore","merge","push","empty","assign","isObject","source","target","j","sourceKey","_test","name","arg","func","_testUnique","filter","test","strict","isStrict","undefined","raw","isRaw","value","err","self","unknownKeys","k","includes","selfError","allow","values","flatten","remove","add","valid","allowOnly","invalid","required","optional","forbidden","applyFunctionToChildren","children","fn","args","root","extraChildren","map","child","join","default","description","isRef","when","condition","then","otherwise","hasOwnProperty","alternativeOptions","prototype","call","is","desc","notes","Array","isArray","tags","meta","example","examples","processed","unknownOptions","option","localState","parent","_validate","errors","process","ex","unit","_prepareEmptyValue","trim","reference","originalValue","isDefaultOptions","settingsCache","_coerce","coerced","_finalizeValue","isDeepDefault","match","get","insensitive","has","invalids","stripUndefined","_base","base","valids","ret","Err","finalValue","defaultValue","_try","some","e","path","change","reason","_validateWithOptions","callback","settings","resolve","reject","Promise","catch","describe","flag","toString","function","v","rules","validator","item","hasRef","label","_getLabel","def","isImmutable","only","equal","disallow","not","exist"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\n// Load modules\r\n\r\nconst Hoek = require('hoek');\r\nconst Settings = require('./settings');\r\nconst Ref = require('../../ref');\r\nconst Errors = require('../../errors');\r\nconst State = require('../state');\r\nconst Symbols = require('../symbols');\r\n\r\n// Delay-loaded to prevent circular dependencies\r\nlet Alternatives = null;\r\nlet Cast = null;\r\nlet Schemas = null;\r\n\r\n\r\n// Declare internals\r\n\r\nconst internals = {\r\n    Set: require('../../set')\r\n};\r\n\r\n\r\ninternals.defaults = {\r\n    abortEarly: true,\r\n    convert: true,\r\n    allowUnknown: false,\r\n    skipFunctions: false,\r\n    stripUnknown: false,\r\n    language: {},\r\n    presence: 'optional',\r\n    strip: false,\r\n    noDefaults: false,\r\n    escapeHtml: false\r\n\r\n    // context: null\r\n};\r\n\r\n\r\nmodule.exports = internals.Any = class {\r\n\r\n    constructor() {\r\n\r\n        Cast = Cast || require('../../cast');\r\n\r\n        this.isJoi = true;\r\n        this._type = 'any';\r\n        this._settings = null;\r\n        this._valids = new internals.Set();\r\n        this._invalids = new internals.Set();\r\n        this._tests = [];\r\n        this._refs = [];\r\n        this._flags = {\r\n            /*\r\n             presence: 'optional',                   // optional, required, forbidden, ignore\r\n             allowOnly: false,\r\n             allowUnknown: undefined,\r\n             default: undefined,\r\n             forbidden: false,\r\n             encoding: undefined,\r\n             insensitive: false,\r\n             trim: false,\r\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\r\n             case: undefined,                        // upper, lower\r\n             empty: undefined,\r\n             func: false,\r\n             raw: false\r\n             */\r\n        };\r\n\r\n        this._description = null;\r\n        this._unit = null;\r\n        this._notes = [];\r\n        this._tags = [];\r\n        this._examples = [];\r\n        this._meta = [];\r\n\r\n        this._inner = {};                           // Hash of arrays of immutable objects\r\n    }\r\n\r\n    _init() {\r\n\r\n        return this;\r\n    }\r\n\r\n    get schemaType() {\r\n\r\n        return this._type;\r\n    }\r\n\r\n    createError(type, context, state, options, flags = this._flags) {\r\n\r\n        return Errors.create(type, context, state, options, flags);\r\n    }\r\n\r\n    createOverrideError(type, context, state, options, message, template) {\r\n\r\n        return Errors.create(type, context, state, options, this._flags, message, template);\r\n    }\r\n\r\n    checkOptions(options) {\r\n\r\n        Schemas = Schemas || require('../../schemas');\r\n\r\n        const result = Schemas.options.validate(options);\r\n\r\n        if (result.error) {\r\n            throw new Error(result.error.details[0].message);\r\n        }\r\n    }\r\n\r\n    clone() {\r\n\r\n        const obj = Object.create(Object.getPrototypeOf(this));\r\n\r\n        obj.isJoi = true;\r\n        obj._currentJoi = this._currentJoi;\r\n        obj._type = this._type;\r\n        obj._settings = this._settings;\r\n        obj._baseType = this._baseType;\r\n        obj._valids = this._valids.slice();\r\n        obj._invalids = this._invalids.slice();\r\n        obj._tests = this._tests.slice();\r\n        obj._refs = this._refs.slice();\r\n        obj._flags = Hoek.clone(this._flags);\r\n\r\n        obj._description = this._description;\r\n        obj._unit = this._unit;\r\n        obj._notes = this._notes.slice();\r\n        obj._tags = this._tags.slice();\r\n        obj._examples = this._examples.slice();\r\n        obj._meta = this._meta.slice();\r\n\r\n        obj._inner = {};\r\n        const inners = Object.keys(this._inner);\r\n        for (let i = 0; i < inners.length; ++i) {\r\n            const key = inners[i];\r\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\r\n        }\r\n\r\n        return obj;\r\n    }\r\n\r\n    concat(schema) {\r\n\r\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\r\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\r\n\r\n        let obj = this.clone();\r\n\r\n        if (this._type === 'any' && schema._type !== 'any') {\r\n\r\n            // Reset values as if we were \"this\"\r\n            const tmpObj = schema.clone();\r\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\r\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\r\n\r\n            for (let i = 0; i < keysToRestore.length; ++i) {\r\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\r\n            }\r\n\r\n            obj = tmpObj;\r\n        }\r\n\r\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\r\n        obj._valids.merge(schema._valids, schema._invalids);\r\n        obj._invalids.merge(schema._invalids, schema._valids);\r\n        obj._tests.push(...schema._tests);\r\n        obj._refs.push(...schema._refs);\r\n        if (obj._flags.empty && schema._flags.empty) {\r\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\r\n            const flags = Object.assign({}, schema._flags);\r\n            delete flags.empty;\r\n            Hoek.merge(obj._flags, flags);\r\n        }\r\n        else if (schema._flags.empty) {\r\n            obj._flags.empty = schema._flags.empty;\r\n            const flags = Object.assign({}, schema._flags);\r\n            delete flags.empty;\r\n            Hoek.merge(obj._flags, flags);\r\n        }\r\n        else {\r\n            Hoek.merge(obj._flags, schema._flags);\r\n        }\r\n\r\n        obj._description = schema._description || obj._description;\r\n        obj._unit = schema._unit || obj._unit;\r\n        obj._notes.push(...schema._notes);\r\n        obj._tags.push(...schema._tags);\r\n        obj._examples.push(...schema._examples);\r\n        obj._meta.push(...schema._meta);\r\n\r\n        const inners = Object.keys(schema._inner);\r\n        const isObject = obj._type === 'object';\r\n        for (let i = 0; i < inners.length; ++i) {\r\n            const key = inners[i];\r\n            const source = schema._inner[key];\r\n            if (source) {\r\n                const target = obj._inner[key];\r\n                if (target) {\r\n                    if (isObject && key === 'children') {\r\n                        const keys = {};\r\n\r\n                        for (let j = 0; j < target.length; ++j) {\r\n                            keys[target[j].key] = j;\r\n                        }\r\n\r\n                        for (let j = 0; j < source.length; ++j) {\r\n                            const sourceKey = source[j].key;\r\n                            if (keys[sourceKey] >= 0) {\r\n                                target[keys[sourceKey]] = {\r\n                                    key: sourceKey,\r\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\r\n                                };\r\n                            }\r\n                            else {\r\n                                target.push(source[j]);\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        obj._inner[key] = obj._inner[key].concat(source);\r\n                    }\r\n                }\r\n                else {\r\n                    obj._inner[key] = source.slice();\r\n                }\r\n            }\r\n        }\r\n\r\n        return obj;\r\n    }\r\n\r\n    _test(name, arg, func, options) {\r\n\r\n        const obj = this.clone();\r\n        obj._tests.push({ func, name, arg, options });\r\n        return obj;\r\n    }\r\n\r\n    _testUnique(name, arg, func, options) {\r\n\r\n        const obj = this.clone();\r\n        obj._tests = obj._tests.filter((test) => test.name !== name);\r\n        obj._tests.push({ func, name, arg, options });\r\n        return obj;\r\n    }\r\n\r\n    options(options) {\r\n\r\n        Hoek.assert(!options.context, 'Cannot override context');\r\n        this.checkOptions(options);\r\n\r\n        const obj = this.clone();\r\n        obj._settings = Settings.concat(obj._settings, options);\r\n        return obj;\r\n    }\r\n\r\n    strict(isStrict) {\r\n\r\n        const obj = this.clone();\r\n\r\n        const convert = isStrict === undefined ? false : !isStrict;\r\n        obj._settings = Settings.concat(obj._settings, { convert });\r\n        return obj;\r\n    }\r\n\r\n    raw(isRaw) {\r\n\r\n        const value = isRaw === undefined ? true : isRaw;\r\n\r\n        if (this._flags.raw === value) {\r\n            return this;\r\n        }\r\n\r\n        const obj = this.clone();\r\n        obj._flags.raw = value;\r\n        return obj;\r\n    }\r\n\r\n    error(err, options = { self: false }) {\r\n\r\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\r\n\r\n        const unknownKeys = Object.keys(options).filter((k) => !['self'].includes(k));\r\n        Hoek.assert(unknownKeys.length === 0, `Options ${unknownKeys} are unknown`);\r\n\r\n        const obj = this.clone();\r\n        obj._flags.error = err;\r\n\r\n        if (options.self) {\r\n            obj._flags.selfError = true;\r\n        }\r\n\r\n        return obj;\r\n    }\r\n\r\n    allow(...values) {\r\n\r\n        const obj = this.clone();\r\n        values = Hoek.flatten(values);\r\n        for (let i = 0; i < values.length; ++i) {\r\n            const value = values[i];\r\n\r\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\r\n            obj._invalids.remove(value);\r\n            obj._valids.add(value, obj._refs);\r\n        }\r\n\r\n        return obj;\r\n    }\r\n\r\n    valid(...values) {\r\n\r\n        const obj = this.allow(...values);\r\n        obj._flags.allowOnly = true;\r\n        return obj;\r\n    }\r\n\r\n    invalid(...values) {\r\n\r\n        const obj = this.clone();\r\n        values = Hoek.flatten(values);\r\n        for (let i = 0; i < values.length; ++i) {\r\n            const value = values[i];\r\n\r\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\r\n            obj._valids.remove(value);\r\n            obj._invalids.add(value, obj._refs);\r\n        }\r\n\r\n        return obj;\r\n    }\r\n\r\n    required() {\r\n\r\n        if (this._flags.presence === 'required') {\r\n            return this;\r\n        }\r\n\r\n        const obj = this.clone();\r\n        obj._flags.presence = 'required';\r\n        return obj;\r\n    }\r\n\r\n    optional() {\r\n\r\n        if (this._flags.presence === 'optional') {\r\n            return this;\r\n        }\r\n\r\n        const obj = this.clone();\r\n        obj._flags.presence = 'optional';\r\n        return obj;\r\n    }\r\n\r\n\r\n    forbidden() {\r\n\r\n        if (this._flags.presence === 'forbidden') {\r\n            return this;\r\n        }\r\n\r\n        const obj = this.clone();\r\n        obj._flags.presence = 'forbidden';\r\n        return obj;\r\n    }\r\n\r\n\r\n    strip() {\r\n\r\n        if (this._flags.strip) {\r\n            return this;\r\n        }\r\n\r\n        const obj = this.clone();\r\n        obj._flags.strip = true;\r\n        return obj;\r\n    }\r\n\r\n    applyFunctionToChildren(children, fn, args = [], root) {\r\n\r\n        children = [].concat(children);\r\n\r\n        if (children.length !== 1 || children[0] !== '') {\r\n            root = root ? (root + '.') : '';\r\n\r\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\r\n\r\n                return root + child;\r\n            });\r\n\r\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\r\n        }\r\n\r\n        return this[fn](...args);\r\n    }\r\n\r\n    default(value, description) {\r\n\r\n        if (typeof value === 'function' &&\r\n            !Ref.isRef(value)) {\r\n\r\n            if (!value.description &&\r\n                description) {\r\n\r\n                value.description = description;\r\n            }\r\n\r\n            if (!this._flags.func) {\r\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\r\n            }\r\n        }\r\n\r\n        const obj = this.clone();\r\n        obj._flags.default = value;\r\n        Ref.push(obj._refs, value);\r\n        return obj;\r\n    }\r\n\r\n    empty(schema) {\r\n\r\n        const obj = this.clone();\r\n        if (schema === undefined) {\r\n            delete obj._flags.empty;\r\n        }\r\n        else {\r\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\r\n        }\r\n\r\n        return obj;\r\n    }\r\n\r\n    when(condition, options) {\r\n\r\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\r\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \"then\" or \"otherwise\"');\r\n\r\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\r\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\r\n\r\n        Alternatives = Alternatives || require('../alternatives');\r\n\r\n        const alternativeOptions = { then, otherwise };\r\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\r\n            alternativeOptions.is = options.is;\r\n        }\r\n\r\n        const obj = Alternatives.when(condition, alternativeOptions);\r\n        obj._flags.presence = 'ignore';\r\n        obj._baseType = this;\r\n\r\n        return obj;\r\n    }\r\n\r\n    description(desc) {\r\n\r\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\r\n\r\n        const obj = this.clone();\r\n        obj._description = desc;\r\n        return obj;\r\n    }\r\n\r\n    notes(notes) {\r\n\r\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\r\n\r\n        const obj = this.clone();\r\n        obj._notes = obj._notes.concat(notes);\r\n        return obj;\r\n    }\r\n\r\n    tags(tags) {\r\n\r\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\r\n\r\n        const obj = this.clone();\r\n        obj._tags = obj._tags.concat(tags);\r\n        return obj;\r\n    }\r\n\r\n    meta(meta) {\r\n\r\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\r\n\r\n        const obj = this.clone();\r\n        obj._meta = obj._meta.concat(meta);\r\n        return obj;\r\n    }\r\n\r\n    example(...examples) {\r\n\r\n        Hoek.assert(examples.length > 0, 'Missing examples');\r\n\r\n        const processed = [];\r\n        for (let i = 0; i < examples.length; ++i) {\r\n            const example = [].concat(examples[i]);\r\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\r\n\r\n            const value = example[0];\r\n            let options = example[1];\r\n            if (options !== undefined) {\r\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\r\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\r\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\r\n            }\r\n            else {\r\n                options = {};\r\n            }\r\n\r\n            const localState = new State('', [], options.parent || null);\r\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\r\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\r\n\r\n            const ex = { value };\r\n            if (Object.keys(options).length) {\r\n                ex.options = options;\r\n            }\r\n\r\n            processed.push(ex);\r\n        }\r\n\r\n        const obj = this.clone();\r\n        obj._examples = processed;\r\n        return obj;\r\n    }\r\n\r\n    unit(name) {\r\n\r\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\r\n\r\n        const obj = this.clone();\r\n        obj._unit = name;\r\n        return obj;\r\n    }\r\n\r\n    _prepareEmptyValue(value) {\r\n\r\n        if (typeof value === 'string' && this._flags.trim) {\r\n            return value.trim();\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    _validate(value, state, options, reference) {\r\n\r\n        const originalValue = value;\r\n\r\n        // Setup state and settings\r\n\r\n        state = state || new State('', [], null, reference);\r\n\r\n        if (this._settings) {\r\n            const isDefaultOptions = options === internals.defaults;\r\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\r\n                options = this._settings[Symbols.settingsCache];\r\n            }\r\n            else {\r\n                options = Settings.concat(options, this._settings);\r\n                if (isDefaultOptions) {\r\n                    this._settings[Symbols.settingsCache] = options;\r\n                }\r\n            }\r\n        }\r\n\r\n        let errors = [];\r\n\r\n        if (this._coerce) {\r\n            const coerced = this._coerce(value, state, options);\r\n            if (coerced.errors) {\r\n                value = coerced.value;\r\n                errors = errors.concat(coerced.errors);\r\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\r\n            }\r\n\r\n            value = coerced.value;\r\n        }\r\n\r\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\r\n            value = undefined;\r\n        }\r\n\r\n        // Check presence requirements\r\n\r\n        const presence = this._flags.presence || options.presence;\r\n        if (presence === 'optional') {\r\n            if (value === undefined) {\r\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\r\n                if (isDeepDefault && this._type === 'object') {\r\n                    value = {};\r\n                }\r\n                else {\r\n                    return this._finalizeValue(value, originalValue, errors, state, options);\r\n                }\r\n            }\r\n        }\r\n        else if (presence === 'required' &&\r\n            value === undefined) {\r\n\r\n            errors.push(this.createError('any.required', null, state, options));\r\n            return this._finalizeValue(value, originalValue, errors, state, options);\r\n        }\r\n        else if (presence === 'forbidden') {\r\n            if (value === undefined) {\r\n                return this._finalizeValue(value, originalValue, errors, state, options);\r\n            }\r\n\r\n            errors.push(this.createError('any.unknown', null, state, options));\r\n            return this._finalizeValue(value, originalValue, errors, state, options);\r\n        }\r\n\r\n        // Check allowed and denied values using the original value\r\n\r\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\r\n        if (match) {\r\n            if (options.convert) {\r\n                value = match.value;\r\n            }\r\n\r\n            return this._finalizeValue(value, originalValue, errors, state, options);\r\n        }\r\n\r\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\r\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\r\n            if (options.abortEarly) {\r\n\r\n                return this._finalizeValue(value, originalValue, errors, state, options);\r\n            }\r\n        }\r\n\r\n        // Convert value and validate type\r\n\r\n        if (this._base) {\r\n            const base = this._base(value, state, options);\r\n            if (base.errors) {\r\n                value = base.value;\r\n                errors = errors.concat(base.errors);\r\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\r\n            }\r\n\r\n            if (base.value !== value) {\r\n                value = base.value;\r\n\r\n                // Check allowed and denied values using the converted value\r\n\r\n                match = this._valids.get(value, state, options, this._flags.insensitive);\r\n                if (match) {\r\n                    value = match.value;\r\n                    return this._finalizeValue(value, originalValue, errors, state, options);\r\n                }\r\n\r\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\r\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\r\n                    if (options.abortEarly) {\r\n                        return this._finalizeValue(value, originalValue, errors, state, options);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Required values did not match\r\n\r\n        if (this._flags.allowOnly) {\r\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\r\n            if (options.abortEarly) {\r\n                return this._finalizeValue(value, originalValue, errors, state, options);\r\n            }\r\n        }\r\n\r\n        // Validate tests\r\n\r\n        for (let i = 0; i < this._tests.length; ++i) {\r\n            const test = this._tests[i];\r\n            const ret = test.func.call(this, value, state, options);\r\n            if (ret instanceof Errors.Err) {\r\n                errors.push(ret);\r\n                if (options.abortEarly) {\r\n                    return this._finalizeValue(value, originalValue, errors, state, options);\r\n                }\r\n            }\r\n            else {\r\n                value = ret;\r\n            }\r\n        }\r\n\r\n        return this._finalizeValue(value, originalValue, errors, state, options);\r\n    }\r\n\r\n    _finalizeValue(value, originalValue, errors, state, options) {\r\n\r\n        let finalValue;\r\n\r\n        if (value !== undefined) {\r\n            finalValue = this._flags.raw ? originalValue : value;\r\n        }\r\n        else if (options.noDefaults) {\r\n            finalValue = value;\r\n        }\r\n        else if (Ref.isRef(this._flags.default)) {\r\n            finalValue = this._flags.default(state.parent, options);\r\n        }\r\n        else if (typeof this._flags.default === 'function' &&\r\n            !(this._flags.func && !this._flags.default.description)) {\r\n\r\n            let args;\r\n\r\n            if (state.parent !== null &&\r\n                this._flags.default.length > 0) {\r\n\r\n                args = [Hoek.clone(state.parent), options];\r\n            }\r\n\r\n            const defaultValue = internals._try(this._flags.default, args);\r\n            finalValue = defaultValue.value;\r\n            if (defaultValue.error) {\r\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\r\n            }\r\n        }\r\n        else {\r\n            finalValue = Hoek.clone(this._flags.default);\r\n        }\r\n\r\n        if (errors.length &&\r\n            typeof this._flags.error === 'function' &&\r\n            (\r\n                !this._flags.selfError ||\r\n                errors.some((e) => state.path.length === e.path.length)\r\n            )\r\n        ) {\r\n            const change = this._flags.error.call(this, errors);\r\n\r\n            if (typeof change === 'string') {\r\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\r\n            }\r\n            else {\r\n                errors = [].concat(change)\r\n                    .map((err) => {\r\n\r\n                        return err instanceof Error ?\r\n                            err :\r\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\r\n                    });\r\n            }\r\n        }\r\n\r\n        return {\r\n            value: this._flags.strip ? undefined : finalValue,\r\n            finalValue,\r\n            errors: errors.length ? errors : null\r\n        };\r\n    }\r\n\r\n    _validateWithOptions(value, options, callback) {\r\n\r\n        if (options) {\r\n            this.checkOptions(options);\r\n        }\r\n\r\n        const settings = Settings.concat(internals.defaults, options);\r\n        const result = this._validate(value, null, settings);\r\n        const errors = Errors.process(result.errors, value);\r\n\r\n        if (callback) {\r\n            return callback(errors, result.value);\r\n        }\r\n\r\n        return {\r\n            error: errors,\r\n            value: result.value,\r\n            then(resolve, reject) {\r\n\r\n                if (errors) {\r\n                    return Promise.reject(errors).catch(reject);\r\n                }\r\n\r\n                return Promise.resolve(result.value).then(resolve);\r\n            },\r\n            catch(reject) {\r\n\r\n                if (errors) {\r\n                    return Promise.reject(errors).catch(reject);\r\n                }\r\n\r\n                return Promise.resolve(result.value);\r\n            }\r\n        };\r\n    }\r\n\r\n    validate(value, options, callback) {\r\n\r\n        if (typeof options === 'function') {\r\n            return this._validateWithOptions(value, null, options);\r\n        }\r\n\r\n        return this._validateWithOptions(value, options, callback);\r\n    }\r\n\r\n    describe() {\r\n\r\n        const description = {\r\n            type: this._type\r\n        };\r\n\r\n        const flags = Object.keys(this._flags);\r\n        if (flags.length) {\r\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\r\n                description.flags = {};\r\n                for (let i = 0; i < flags.length; ++i) {\r\n                    const flag = flags[i];\r\n                    if (flag === 'empty') {\r\n                        description.flags[flag] = this._flags[flag].describe();\r\n                    }\r\n                    else if (flag === 'default') {\r\n                        if (Ref.isRef(this._flags[flag])) {\r\n                            description.flags[flag] = this._flags[flag].toString();\r\n                        }\r\n                        else if (typeof this._flags[flag] === 'function') {\r\n                            description.flags[flag] = {\r\n                                description: this._flags[flag].description,\r\n                                function   : this._flags[flag]\r\n                            };\r\n                        }\r\n                        else {\r\n                            description.flags[flag] = this._flags[flag];\r\n                        }\r\n                    }\r\n                    else if (flag === 'lazy' || flag === 'label') {\r\n                        // We don't want it in the description\r\n                    }\r\n                    else {\r\n                        description.flags[flag] = this._flags[flag];\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                description.flags = this._flags;\r\n            }\r\n        }\r\n\r\n        if (this._settings) {\r\n            description.options = Hoek.clone(this._settings);\r\n        }\r\n\r\n        if (this._baseType) {\r\n            description.base = this._baseType.describe();\r\n        }\r\n\r\n        if (this._description) {\r\n            description.description = this._description;\r\n        }\r\n\r\n        if (this._notes.length) {\r\n            description.notes = this._notes;\r\n        }\r\n\r\n        if (this._tags.length) {\r\n            description.tags = this._tags;\r\n        }\r\n\r\n        if (this._meta.length) {\r\n            description.meta = this._meta;\r\n        }\r\n\r\n        if (this._examples.length) {\r\n            description.examples = this._examples;\r\n        }\r\n\r\n        if (this._unit) {\r\n            description.unit = this._unit;\r\n        }\r\n\r\n        const valids = this._valids.values();\r\n        if (valids.length) {\r\n            description.valids = valids.map((v) => {\r\n\r\n                return Ref.isRef(v) ? v.toString() : v;\r\n            });\r\n        }\r\n\r\n        const invalids = this._invalids.values();\r\n        if (invalids.length) {\r\n            description.invalids = invalids.map((v) => {\r\n\r\n                return Ref.isRef(v) ? v.toString() : v;\r\n            });\r\n        }\r\n\r\n        description.rules = [];\r\n\r\n        for (let i = 0; i < this._tests.length; ++i) {\r\n            const validator = this._tests[i];\r\n            const item = { name: validator.name };\r\n\r\n            if (validator.arg !== void 0) {\r\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\r\n            }\r\n\r\n            const options = validator.options;\r\n            if (options) {\r\n                if (options.hasRef) {\r\n                    item.arg = {};\r\n                    const keys = Object.keys(validator.arg);\r\n                    for (let j = 0; j < keys.length; ++j) {\r\n                        const key = keys[j];\r\n                        const value = validator.arg[key];\r\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\r\n                    }\r\n                }\r\n\r\n                if (typeof options.description === 'string') {\r\n                    item.description = options.description;\r\n                }\r\n                else if (typeof options.description === 'function') {\r\n                    item.description = options.description(item.arg);\r\n                }\r\n            }\r\n\r\n            description.rules.push(item);\r\n        }\r\n\r\n        if (!description.rules.length) {\r\n            delete description.rules;\r\n        }\r\n\r\n        const label = this._getLabel();\r\n        if (label) {\r\n            description.label = label;\r\n        }\r\n\r\n        return description;\r\n    }\r\n\r\n    label(name) {\r\n\r\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\r\n\r\n        const obj = this.clone();\r\n        obj._flags.label = name;\r\n        return obj;\r\n    }\r\n\r\n    _getLabel(def) {\r\n\r\n        return this._flags.label || def;\r\n    }\r\n\r\n};\r\n\r\n\r\ninternals.Any.prototype.isImmutable = true;     // Prevents Hoek from deep cloning schema objects\r\n\r\n// Aliases\r\n\r\ninternals.Any.prototype.only = internals.Any.prototype.equal = internals.Any.prototype.valid;\r\ninternals.Any.prototype.disallow = internals.Any.prototype.not = internals.Any.prototype.invalid;\r\ninternals.Any.prototype.exist = internals.Any.prototype.required;\r\n\r\n\r\ninternals._try = function (fn, args = []) {\r\n\r\n    let err;\r\n    let result;\r\n\r\n    try {\r\n        result = fn(...args);\r\n    }\r\n    catch (e) {\r\n        err = e;\r\n    }\r\n\r\n    return {\r\n        value: result,\r\n        error: err\r\n    };\r\n};\r\n"]},"metadata":{},"sourceType":"script"}